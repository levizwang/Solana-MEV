# Solana MEV 实战开发指南：拾荒者 (The Scavenger) 模式

## 1. 战略总纲 (Executive Summary)

*   **当前处境**：10 SOL 本金，Python 技术栈，非顶级节点。
*   **核心矛盾**：主流池（SOL-USDC-RAY）已被 FPGA/Rust 顶级战队垄断，普通代码在纳秒级竞争中存活率为 0。
*   **战略定位**：**长尾拾荒者 (Long-tail Scavenger)**。
    *   避开 Top 100 代币。
    *   专注于 **新盘子 (Pump.fun迁移)** 和 **僵尸池 (Low TVL)**。
    *   利用 Jito Bundle 实现**原子化、无风险**套利。
*   **获利逻辑**：`利润 = (价差 - Gas - Jito小费) > 0`。只要 Bundle 模拟成功即获利，模拟失败不扣钱。

---

## 2. 技术架构 (The Stack)

为了平衡开发效率与执行性能，推荐采用 **"Python 侦察 + Rust 执行"** 的混合架构，或者在初期使用 **纯 Rust** 以适应 Solana 生态。

| 模块 | 推荐技术 | 说明 |
| :--- | :--- | :--- |
| **语言** | **Rust** (必须) | Solana 的原生语言，处理序列化（Borsh）、签名验证、Jito SDK 交互的唯一选择。Python 可用于盘后数据分析。 |
| **节点/数据源** | **Helius / Triton** | 购买支持 **Geyser gRPC** 的开发者套餐（约 $50-$100/mo）。不要用 HTTP 轮询。 |
| **交易引擎** | **Jito Searcher SDK** | 使用 `jito-labs/searcher-examples` 作为脚手架。 |
| **策略逻辑** | **Hard-coded Logic** | 针对特定代币对写死逻辑，不要跑通用的 Bellman-Ford 算法。 |

---

## 3. 实战开发路线图 (Implementation Roadmap)

### 第一阶段：基础设施搭建 (Day 1-2)

1.  **环境配置**：
    *   安装 Rust 工具链 (`rustup`).
    *   安装 Solana CLI (`sh -c "$(curl -sSfL https://release.solana.com/v1.18.x/install)"`).
    *   生成专用钱包：`solana-keygen new -o scavenger.json` (存入 1 SOL 作为 Gas/Tip，其余 9 SOL 转为 WSOL 用于交易)。

2.  **获取 Jito 访问权限**：
    *   虽然 Jito 目前是开放的，但你需要加入他们的 Discord 或查阅文档获取最新的 Block Engine URL（如 `amsterdam.mainnet.block-engine.jito.wtf`）。
    *   你需要配置 `Keypair` 进行 gRPC 签名认证。

3.  **克隆脚手架**：
    ```bash
    git clone https://github.com/jito-labs/searcher-examples
    cd searcher-examples
    # 尝试运行 backrun 示例，确保能连接到 Block Engine
    cargo run --example backrun
    ```

---

### 第二阶段：侦察系统 - 寻找“猎物” (Day 3-4)

不要扫描全网。你需要一个“狙击镜”。

**目标**：监听 Raydium 的 `LiquidityPoolV4` 相关的 `Initialize` 或 `Deposit` 事件。

**Rust 代码思路 (Geyser gRPC 过滤器)**：

```rust
// 伪代码：配置 gRPC 订阅过滤器
let transactions_filter = SubscribeUpdateTransactionFilter {
    vote: Some(false),
    failed: Some(false),
    // 过滤 Raydium Liquidity Pool V4 Program ID
    account_include: vec!["675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8".to_string()], 
    ..Default::default()
};

// 建立流连接
let mut stream = geyser_client.subscribe_transaction_updates(transactions_filter).await?;

while let Some(message) = stream.next().await {
    // 解析交易日志，判断是否为新池子创建
    if let Some(log) = parse_logs(&message) {
        if log.contains("Initialize") {
            println!("发现新池子！Token地址: {:?}", extract_token_mint(log));
            // 触发套利逻辑
        }
    }
}
```

---

### 第三阶段：策略执行 - 简单的原子搬砖 (Day 5-7)

**场景**：发现新币 $MEME，在 Raydium 价格 100，在 Orca（或其他小 DEX）价格 90。
**动作**：Orca 买 -> Raydium 卖 -> Jito Tip。

**核心 Rust 实现 (原子交易组装)**：

我们已经在 `src/strategy/arbitrage.rs` 中实现了这一逻辑的核心骨架：

```rust
// 伪代码流程
async fn execute_arbitrage(...) {
    // 1. 构建 Orca Buy 指令
    let buy_ix = orca::swap(...);
    
    // 2. 构建 Raydium Sell 指令
    let sell_ix = raydium::swap(...);
    
    // 3. 构建 Jito Tip 指令 (贿赂验证者)
    let tip_ix = system_instruction::transfer(..., tip_account, ...);
    
    // 4. 原子打包 (Atomic Bundle)
    let tx = Transaction::new_signed_with_payer(
        &[buy_ix, sell_ix, tip_ix], // 只要其中一个失败，整笔交易回滚，本金安全
        ...
    );
    
    // 5. 发送给 Jito Block Engine
    jito_client.send_bundle(vec![tx]).await?;
}
```

**待完善模块**：
1.  **Orca Adapter (`src/strategy/orca.rs`)**: 目前仅实现了指令结构体，需要补充真实的 `TickArray` 计算和账户获取逻辑（较为复杂，通常需要 `get_program_accounts` 辅助）。
2.  **多路价格监听**: 需要在 `Scout` 中增加对 Orca Whirlpool 的监听，或者实现高频轮询价格。
3.  **利润计算器**: 在发送 Bundle 前，必须在本地模拟执行 (Simulation)，确保 `最终余额 > 初始余额 + Gas + Tip`。

---    client: &mut SearcherServiceClient<Channel>,
    payer: &Keypair,
    pool_a:Pubkey, // 低价池
    pool_b: Pubkey, // 高价池
    amount_in: u64, // 投入 5 SOL
) -> Result<()> {

    // 1. 构建 Swap 指令 (需要引入 raydium/orca 的 rust sdk 或手写 instruction data)
    let swap_inst_1 = orca::swap(pool_a, payer.pubkey(), amount_in, ...); // 买入
    let swap_inst_2 = raydium::swap(pool_b, payer.pubkey(), amount_out_expected, ...); // 卖出

    // 2. 计算 Tip (贿赂)
    // 假设预期利润是 0.1 SOL，我们给 90% (0.09 SOL) 给 Jito 矿工
    // Jito Tip 账户列表是公开的，随机选一个
    let tip_account = Pubkey::from_str("96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5").unwrap();
    let tip_inst = system_instruction::transfer(&payer.pubkey(), &tip_account, 90_000_000); // 0.09 SOL

    // 3. 构建原子交易 (Atomic Transaction)
    // 注意：可以将多条指令塞进一个 Tx，也可以多个 Tx 塞进一个 Bundle
    // 为了省 size，通常塞进一个 VersionedTransaction
    let tx = VersionedTransaction::try_new(
        VersionedMessage::V0(v0::Message::try_compile(
            &payer.pubkey(),
            &[swap_inst_1, swap_inst_2, tip_inst], // 顺序：买 -> 卖 -> 贿赂
            &[address_lookup_table], // 使用 ALT 节省空间
            blockhash,
        )?),
        &[payer], // 签名
    )?;

    // 4. 发送 Bundle
    let bundle_results = send_bundle_with_confirmation(
        &[tx], 
        rpc_client, 
        client, 
        &mut bundle_subscription
    ).await;

    match bundle_results {
        Ok(_) => println!("✅ 套利成功！"),
        Err(e) => println!("❌ 失败 (无成本): {:?}", e), // 可能是滑点超了，或者被别人抢了
    }
    
    Ok(())
}
```

---

## 4. 关键风控与参数 (Risk Management)

对于你的 10 SOL，这是保命法则：

1.  **Tip 策略 (动态计算)**：
    *   不要写死 Tip。
    *   在代码中模拟执行（Simulation）：`Estimated_Profit = Out_Amount - In_Amount`。
    *   `Tip = Estimated_Profit * 0.9` (对于竞争激烈的新池子)。
    *   `Tip = Estimated_Profit * 0.5` (对于僵尸池，没人抢，少给点)。
    *   **千万不要** `Tip > Profit`，否则你会亏本金。

2.  **滑点保护 (Slippage)**：
    *   在 Swap 指令中，`Minimum_Out` 参数必须严格设置。
    *   如果预期卖出得 10.5 SOL，设置 `Minimum_Out = 10.01 SOL` (保本 + 微利)。
    *   如果市场剧烈波动导致换不回 10.01 SOL，指令会 revert，Jito Bundle 模拟失败，交易不上链。**这是你的安全气囊。**

3.  **WSOL 管理**：
    *   Solana 上的 DEX 大多交易 WSOL (Wrapped SOL)。
    *   确保你的脚本会自动 `SyncNative`，或者长期持有 WSOL，不要频繁做 SOL <-> WSOL 的 unwrap/wrap，浪费 Compute Unit。